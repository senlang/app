/**
	************************************************************
	************************************************************
	************************************************************
	*	文件名： 	uasrt_down.c
	*
	*	作者： 		
	*
	*	日期： 		2016-11-23
	*
	*	版本： 		V1.0
	*
	*	说明： 		网络设备数据IO层
	*
	*	修改记录：	
	************************************************************
	************************************************************
	************************************************************
**/

#include "stm32f10x.h"  //单片机头文件

#include "data_io.h"		//网络设备数据IO
#include "stm32_uart2.h"

#include "delay.h"		//硬件驱动


#include "usart.h"


#include <stdarg.h>	//C库
#include <string.h>

UART_DATA_INFO down_recv_data_info;
UART_DATA uasrt2_recv_data[UART_MAX_IDX];

int uart2_enqueue_idx = 0;
int uart2_dequeue_idx = 0;

extern OS_EVENT *SemOfUart2RecvData;	//uart2 串口接收数据信号量


void UART2_IO_ClearRecive(void);

/**
   * @brief  配置嵌套向量中断控制器NVIC
   * @param  无
   * @retval 无
   */
 static void Down_NVIC_Configuration(void)
 {
   NVIC_InitTypeDef NVIC_InitStructure;
   
   /* 嵌套向量中断控制器组选择 */
   NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   
   /* 配置USART为中断源 */
   NVIC_InitStructure.NVIC_IRQChannel = DOWN_USART_IRQ;
   /* 抢断优先级*/
   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
   /* 子优先级 */
   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
   /* 使能中断 */
   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   /* 初始化配置NVIC */
   NVIC_Init(&NVIC_InitStructure);
 }
 
  /**
   * @brief  USART GPIO 配置,工作参数配置
   * @param  无
   * @retval 无
   */
 void Down_USART_Config(void)
 {
	 GPIO_InitTypeDef GPIO_InitStructure;
	 USART_InitTypeDef USART_InitStructure;
 
	 // 打开串口GPIO的时钟
	 DOWN_USART_GPIO_APBxClkCmd(DOWN_USART_GPIO_CLK, ENABLE);
	 
	 // 打开串口外设的时钟
	 UP_USART_APBxClkCmd(DOWN_USART_CLK, ENABLE);
 
	 // 将USART Tx的GPIO配置为推挽复用模式
	 GPIO_InitStructure.GPIO_Pin = DOWN_USART_TX_GPIO_PIN;
	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	 GPIO_Init(DOWN_USART_TX_GPIO_PORT, &GPIO_InitStructure);
 
   // 将USART Rx的GPIO配置为浮空输入模式
	 GPIO_InitStructure.GPIO_Pin = DOWN_USART_RX_GPIO_PIN;
	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	 GPIO_Init(DOWN_USART_RX_GPIO_PORT, &GPIO_InitStructure);
	 
	 // 配置串口的工作参数
	 // 配置波特率
	 USART_InitStructure.USART_BaudRate = DOWN_USART_BAUDRATE;
	 // 配置 针数据字长
	 USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	 // 配置停止位
	 USART_InitStructure.USART_StopBits = USART_StopBits_1;
	 // 配置校验位
	 USART_InitStructure.USART_Parity = USART_Parity_No ;
	 // 配置硬件流控制
	 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	 // 配置工作模式，收发一起
	 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	 // 完成串口的初始化配置
	 USART_Init(DOWN_USARTx, &USART_InitStructure);
	 
	 // 串口中断优先级配置
	 Down_NVIC_Configuration();
	 
	 // 使能串口接收中断
	 USART_ITConfig(DOWN_USARTx, USART_IT_RXNE, ENABLE);	 
	 
	 // 使能串口
	 USART_Cmd(DOWN_USARTx, ENABLE);		 
 
   // 清除发送完成标志
	 //USART_ClearFlag(USART1, USART_FLAG_TC);	   
 }
 
 
 
 /*
 ************************************************************
 *	 函数名称：  Usart2_Init
 *
 *	 函数功能：  串口2初始化
 *
 *	 入口参数：  baud：设定的波特率
 *
 *	 返回参数：  无
 *
 *	 说明： 	 TX-PA2 	 RX-PA3
 ************************************************************
 */
void Usart2_Init(unsigned int baud)
{

	
	GPIO_InitTypeDef gpioInitStruct;
	USART_InitTypeDef usartInitStruct;
	NVIC_InitTypeDef nvicInitStruct;
		
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);


	//PA2	 TXD
	gpioInitStruct.GPIO_Mode = GPIO_Mode_AF_PP;
	gpioInitStruct.GPIO_Pin = GPIO_Pin_2;
	gpioInitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &gpioInitStruct);

	//PA3	 RXD
	gpioInitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	gpioInitStruct.GPIO_Pin = GPIO_Pin_3;
	gpioInitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &gpioInitStruct);

	usartInitStruct.USART_BaudRate = baud;
	usartInitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	 //无硬件流控
	usartInitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;					 //接收和发送
	usartInitStruct.USART_Parity = USART_Parity_No;								 //无校验
	usartInitStruct.USART_StopBits = USART_StopBits_1; 							 //1位停止位
	usartInitStruct.USART_WordLength = USART_WordLength_8b;						 //8位数据位
	USART_Init(USART2, &usartInitStruct);

	USART_Cmd(USART2, ENABLE); 													 //使能串口

	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); 								 //使能接收中断

	nvicInitStruct.NVIC_IRQChannel = USART2_IRQn;
	nvicInitStruct.NVIC_IRQChannelCmd = ENABLE;
	nvicInitStruct.NVIC_IRQChannelPreemptionPriority = 0;
	nvicInitStruct.NVIC_IRQChannelSubPriority = 2;
	NVIC_Init(&nvicInitStruct);


	USART_GetFlagStatus(USART2, USART_FLAG_TC);
	memset(&uasrt2_recv_data[uart2_enqueue_idx], 0, sizeof(UART_DATA));
}

/*
************************************************************
*	函数名称：	NET_IO_Send
*
*	函数功能：	发送数据
*
*	入口参数：	str：需要发送的数据
*				len：数据长度
*
*	返回参数：	无
*
*	说明：		底层的数据发送驱动
*
************************************************************
*/
void UART2_IO_Send(unsigned char *str, unsigned short len)
{
	unsigned short count = 0;
	
	UsartPrintf(USART_DEBUG, "UART2 Send[%d] : ", len);
	for(; count < len; count++)											//发送一帧数据
	{
		UsartPrintf(USART_DEBUG, "0x%02x,", *(str + count));
		USART_SendData(USART2, *(str + count));
		
		while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);
	}
	UsartPrintf(USART_DEBUG, "\r\n\r\n");
}

/*
************************************************************
*	函数名称：	NET_IO_WaitRecive
*
*	函数功能：	等待接收完成
*
*	入口参数：	无
*
*	返回参数：	REV_OK-接收完成		REV_WAIT-接收超时未完成
*
*	说明：		循环调用检测是否接收完成
************************************************************
*/
_Bool UART2_IO_WaitRecive(void)
{
	//UsartPrintf(USART_DEBUG, "WaitReceive:%d,%d\r\n", uasrt2_recv_data[uart2_enqueue_idx].dataLen, uasrt2_recv_data[uart2_enqueue_idx].dataLenPre);

	if(uasrt2_recv_data[uart2_enqueue_idx].dataLen == 0) 						//如果接收计数为0 则说明没有处于接收数据中，所以直接跳出，结束函数
		return REV_WAIT;
		
	if(uasrt2_recv_data[uart2_enqueue_idx].dataLen == uasrt2_recv_data[uart2_enqueue_idx].dataLenPre)	//如果上一次的值和这次相同，则说明接收完毕
	{
		//down_recv_data_info.dataLen = 0;						//清0接收计数
		return REV_OK;								//返回接收完成标志
	}
		
	uasrt2_recv_data[uart2_enqueue_idx].dataLenPre = uasrt2_recv_data[uart2_enqueue_idx].dataLen;		//置为相同
	return REV_WAIT;								//返回接收未完成标志

}

/*
************************************************************
*	函数名称：	NET_IO_ClearRecive
*
*	函数功能：	清空缓存
*
*	入口参数：	无
*
*	返回参数：	无
*
*	说明：		
************************************************************
*/
void UART2_IO_ClearRecive(void)
{	
	memset(&uasrt2_recv_data[uart2_enqueue_idx], 0, sizeof(UART_DATA));
}

/*
************************************************************
*	函数名称：	USART2_IRQHandler
*
*	函数功能：	接收中断
*
*	入口参数：	无
*
*	返回参数：	无
*
*	说明：		
************************************************************
*/
void USART2_IRQHandler(void)
{
	uint8_t len;
	
	RTOS_EnterInt();

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) //接收中断
	{
		len = uasrt2_recv_data[uart2_enqueue_idx].dataLen;
		uasrt2_recv_data[uart2_enqueue_idx].buf[len] = USART2->DR;	//读取接收到的数据
		if(len < UART_BUF_MAX_LEN - 1)
		{
			len++;
			uasrt2_recv_data[uart2_enqueue_idx].dataLen = len;
		}
		
		USART_ClearFlag(USART2, USART_FLAG_RXNE);
		OSSemPost(SemOfUart2RecvData);
	}
	
	RTOS_ExitInt();

}

int UART2_IO_Receive(void)
{

	if(UART2_IO_WaitRecive() != REV_OK)
	{
		return 0;
	}

	uasrt2_recv_data[uart2_enqueue_idx].status = 1;
	return uasrt2_recv_data[uart2_enqueue_idx].dataLen;
}




//初始化IO 串口2
//pclk1:PCLK1时钟频率(Mhz)
//bound:波特率	  
void RS485_Init(u32 bound)
{  
    GPIO_InitTypeDef GPIO_InitStructure;
  	USART_InitTypeDef USART_InitStructure;
 	NVIC_InitTypeDef NVIC_InitStructure;
 
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC, ENABLE);//使能GPIOA时钟
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);//使能USART2时钟
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;				 //PA7端口配置
 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
 	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 	GPIO_Init(GPIOA, &GPIO_InitStructure);
 
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;	//PA2
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽
    GPIO_Init(GPIOA, &GPIO_InitStructure);
   
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PA3
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入
    GPIO_Init(GPIOA, &GPIO_InitStructure);  

	RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2,ENABLE);//复位串口2
	RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2,DISABLE);//停止复位
 
	
 	#ifdef EN_USART2_RX		  	//如果使能了接收
	USART_InitStructure.USART_BaudRate = bound;//一般设置为115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//8位数据长度
	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
	USART_InitStructure.USART_Parity = USART_Parity_No;///奇偶校验位
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式

    USART_Init(USART2, &USART_InitStructure); ; //初始化串口
  
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; //使能串口2中断
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; //先占优先级2级
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //从优先级2级
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道
	NVIC_Init(&NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
 
    USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启中断
   
    USART_Cmd(USART2, ENABLE);                    //使能串口 

 	#endif

	RS485_TX_EN=0;			//默认为接收模式
}



//RS485发送len个字节.
//buf:发送区首地址
//len:发送的字节数
void RS485_Send_Data(u8 *buf,u8 len)
{
	u8 t;
	
	UsartPrintf(USART_DEBUG, "RS485 Send[%d] : ", len);
	for(t=0;t<len;t++)	
	{
		UsartPrintf(USART_DEBUG, "0x%02x,", *(buf + t));
	}
	UsartPrintf(USART_DEBUG, "\r\n\r\n");
		
	RS485_TX_EN=1;			//设置为发送模式
  	for(t=0;t<len;t++)		//循环发送数据
	{		   
		while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);	  
		USART_SendData(USART2,buf[t]);
	}	 
	while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);	
	
	RS485_TX_EN=0;				//设置为接收模式	
}


